#!/usr/bin/env python3
#-*- coding: UTF-8 -*-

# Copyright (c) 2014-2017, Daemon Developers
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of the Daemon developers nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL DAEMON DEVELOPERS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


import yaml
import re
import sys
import os.path
import argparse
from copy import deepcopy

header_prefix = 'THIS FILE IS AUTOGENERATED, DO NOT MODIFY'
deprecated_prefix = 'DEPRECATED! DEPRECATED! DEPRECATED!'
recommended_prefix = 'RECOMMENDED TO USE:'

bad_token_re = re.compile(r'[}{)(\':\s]', re.M)

def escape_token(t):
    if bad_token_re.search(t):
        if t.find('"') >= 0:
            raise Exception('Bad token: {}'.format(t))
        return '"{}"'.format(t)
    return t

def color_to_float_triple(h):
    hexes = [h[:2], h[2:4], h[4:]]
    return [round(int(x, 16) / 255.0, 3) for x in hexes]

def color_to_float_triple256(h):
    hexes = [h[:2], h[2:4], h[4:]]
    return [int(x, 16) for x in hexes]

def list_of_dicts_to_list_of_tuples(dd):
    res = []
    for d in dd:
        for k, v in d.items():
            res.append((k, v))
            break
    return res

def fmt_float(f):
    x = '{:f}'.format(f)
    if 'e' in x:
        return x
    return x.rstrip('0').rstrip('.')

def _output_float(v):
    return fmt_float(v)

def _output_vec2_float(v):
    return ' '.join(_output_float(vv) for vv in v)

def _output_time_2float(v):
    if isinstance(v, (list, tuple)):
        return _output_vec2_float(v)
    return str(v)

def _output_vec3_float(v):
    return ' '.join(_output_float(vv) for vv in v)

def _output_vec4_float(v):
    return ' '.join(_output_float(vv) for vv in v)

def _output_vec9_float(v):
    return ' '.join(_output_float(vv) for vv in v)

def _output_float_array(v):
    return ' '.join(_output_float(vv) for vv in v)

def _output_vec3_int(v):
    return ' '.join(_output_float(vv) for vv in v)

def outvalue(v, _type):
    ct = canonize_type(_type)
    func_name = '_output_' + ct
    if _type is None or func_name not in globals():
        return str(v)
    return globals()[func_name](v)

label_re = re.compile(r'^\s*\[([\w\d\s,]+)\]')
def sort_properties(props):
    o = []
    for key, desc in props.items():
        m = label_re.findall(desc)
        if not m:
            o.append((1, '', key))
            continue
        if 'required' in m[0]:
            o.append((0, m[0], key))
        else:
            o.append((1, m[0], key))
    for _, _, key in sorted(o):
        yield key, props[key]


# ==============================================================================
# entity output in GtkRadiant format (also supported by NetRadiant)

# https://github.com/TTimo/GtkRadiant/issues/262
dont_place_dummy_flag = True

heading = '------ {} ------'

class Q3DefPrinter:
    def print_header(self, fp):
        print('// {}'.format(header_prefix))
        print('//')

        for line in fp.readlines():
            print("// {}".format(line).rstrip())

        print()

    def print_footer(self):
        pass

    def print_entity_head(self, e):
        name = escape_token(e['name'])
        color = '({} {} {})'.format(*(fmt_float(f) for f in color_to_float_triple(e['color'])))
        flags = [escape_token(k) for k, _ in e.get('flags', [])]
        if 'size_min' in e and 'size_max' in e:
            sizes = ' ({} {} {}) ({} {} {})'.format(*(fmt_float(f) for f in e['size_min'] + e['size_max']))
        else:
            sizes = ''
            if not dont_place_dummy_flag:
                flags.insert(0, escape_token('?'))
        flags = ' '.join(flags)
        if flags:
            flags = ' ' + flags
        print('/*QUAKED {} {}{}{}'.format(name, color, sizes, flags))

    def print_flag_desc(self, e):
        flags = []
        for k, v in e.get('flags', []):
            if k == '-' or not v:
                continue
            flags.append('{}: {}'.format(k, v))
        if flags:
            print(heading.format('FLAGS'))
            for v in flags:
                print(v)

    def print_prop_desc(self, e, dt, pr_types, pr_defaults, pr_ranges, pr_eg):
        if 'props' not in e or not e['props']:
            return

        print(heading.format('PROPERTIES'))
        proptypes, propdefaults, propranges, propreplace, propeg, boolvalues = \
            (e.get(k, {}) for k in ('proptypes', 'propdefaults', 'propranges', 'propreplace', 'propeg', 'boolvalues'))

        for k, v in sort_properties(e['props']):
            _type = proptypes[k] if k in proptypes else (dt[k] if k in dt else None)
            _bool = k in boolvalues
            info = []
            if pr_types and _type is not None:
                info.append(_type)
            if pr_eg and k in propeg:
                info.append('eg: {}'.format(outvalue(propeg[k], _type)))
            if pr_ranges and k in propranges:
                v1, v2 = propranges[k]
                info.append('{}..{}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_ranges and _bool:
                v1, v2 = boolvalues[k]
                info.append('{} or {}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_defaults and k in propdefaults:
                v1 = propdefaults[k]
                if _bool:
                    v1 = boolvalues[k][1 if v1 else 0]
                info.append('def: {}'.format(outvalue(v1, _type)))
            if info:
                info = ' ({})'.format(', '.join(info))
            else:
                info = ''
            if k in propreplace:
                for _from, _to in propreplace[k].items():
                    v = v.replace(_from, _to)
            print('{}: {}{}'.format(k, v.rstrip(), info))

    def print_common_desc(self, e):
        if e.get('desc', '').strip():
            print(heading.format('DESCRIPTION'))
            v = e['desc']
            if 'descreplace' in e:
                for _from, _to in e['descreplace'].items():
                    v = v.replace(_from, _to)
            print(v)

    def print_specials(self, e):
        if 'specials' in e and e['specials']:
            for k, v in e['specials'].items():
                print('{}="{}"'.format(k, v))

    def print_entity(self, e, dt, pr_types=False, pr_defaults=False, pr_ranges=False, pr_eg=False):
        self.print_entity_head(e)
        if e.get('deprecated'):
            print(deprecated_prefix)
            if e.get('aliasof'):
                print('{} {}'.format(recommended_prefix, e.get('aliasof')))
        self.print_flag_desc(e)
        self.print_prop_desc(e, dt, pr_types, pr_defaults, pr_ranges, pr_eg)
        self.print_common_desc(e)
        self.print_specials(e)
        print('*/')
        print()


# ==============================================================================
# Entity output in Doom 3 def format used by DarkRadiant

class D3DefPrinter:
    @staticmethod
    def print_key_comment_line(text):
        print('\t// {}'.format(text))

    @staticmethod
    def print_key(key_name, value):
        value = value.replace('\n', '\\n').replace('"', '\\"')
        print('\t"{}" "{}"'.format(key_name, value))

    def print_header(self, fp):
        print('/* {}'.format(header_prefix))
        print()

        for line in fp.readlines():
            print(line.rstrip())

        print('*/')
        print()

    def print_footer(self):
        pass

    def print_entity_head(self, e):
        name = escape_token(e['name'])
        print('entityDef ' +  name)
        print('{')

        # FIXME: DarkRadiant requires idLight on light entity.
        # Either check for this and report to the user,
        # either fix it for the user.
        if "d3Class" in e.keys():
            self.print_key_comment_line('Class')
            self.print_key("spawnclass", e["d3Class"])
            print()

# We already preprocess the inheritance
#        if "extend" in e.keys():
#            self.print_key("inherit", name)
#            print()

        desc = ''
        if 'desc' in e:
            desc = e['desc']

        if e.get("deprecated"):
            self.print_key_comment_line('Deprecated')
            self.print_key("editor_displayFolder", "Deprecated")
            desc_prefix = '{}\\n'.format(deprecated_prefix)
            if e.get('aliasof'):
                desc_prefix = '{}{} {}\\n'.format(desc_prefix, recommended_prefix, e.get('aliasof'))
            desc = '{}\\n{}'.format(desc_prefix, desc)

        if 'desc' != '':
            self.print_key_comment_line('Description')
            self.print_key('editor_usage', desc)
            print()

        self.print_key_comment_line('Editor color')
        self.print_key('editor_color', e['color'])
        print()

        self.print_key_comment_line('Editor sizes')

        if 'size_min' in e and 'size_max' in e:
            self.print_key('editor_mins', '{} {} {}'.format(*(fmt_float(f) for f in e['size_min'])))
            self.print_key('editor_maxs', '{} {} {}'.format(*(fmt_float(f) for f in e['size_max'])))
        else:
            self.print_key('editor_mins', '?')
            self.print_key('editor_maxs', '?')

        print()

    def print_entity_foot(self):
        print('}')
        print()

    def print_prop_desc(self, e, dt, pr_types=False, pr_defaults=False, pr_ranges=False, pr_eg=False):
        if 'props' not in e or not e['props']:
            return

        proptypes, propdefaults, propranges, propreplace, propeg, boolvalues = \
            (e.get(k, {}) for k in ('proptypes', 'propdefaults', 'propranges', 'propreplace', 'propeg', 'boolvalues'))

        default_list = []

        self.print_key_comment_line('Property description')
        for k, v in sort_properties(e['props']):
            _type = proptypes[k] if k in proptypes else (dt[k] if k in dt else None)
            _bool = k in boolvalues
            info = []

            default_value  = ''
            if pr_types and _type is not None:
                info.append(_type)
            if pr_eg and k in propeg:
                info.append('eg: {}'.format(outvalue(propeg[k], _type)))
            if pr_ranges and k in propranges:
                v1, v2 = propranges[k]
                info.append('{}..{}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_ranges and _bool:
                v1, v2 = boolvalues[k]
                info.append('{} or {}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_defaults and k in propdefaults:
                v1 = propdefaults[k]
                if _bool:
                    v1 = boolvalues[k][1 if v1 else 0]
                info.append('def: {}'.format(outvalue(v1, _type)))
                default_value=outvalue(v1, _type)
            if info != []:
                info = ' ({})'.format(', '.join(info))
            else:
                info = ''
            if k in propreplace:
                for _from, _to in propreplace[k].items():
                    v = v.replace(_from, _to)

            desc = '{}{}'.format(v.rstrip(), info)
            if _bool or _type == 'bool':
                self.print_key('editor_bool ' + k, desc)
            else:
                if _type == 'float':
                    self.print_key('editor_float ' + k, desc)
                else:
                    self.print_key('editor_var ' + k, desc)

                default_list.append((k, default_value))

        if default_list != []:
            print()

            self.print_key_comment_line('Property default value')

            for k, v in default_list:
                self.print_key(k, v)

    def print_specials(self, e):
        if 'specials' in e and e['specials']:
            print()

            for k, v in e['specials'].items():
                self.print_key(k, v)

    def print_entity(self, e, dt, pr_types=False, pr_defaults=False, pr_ranges=False, pr_eg=False):
        self.print_entity_head(e)
        self.print_prop_desc(e, dt, pr_types, pr_defaults, pr_ranges, pr_eg)
        # FIXME: I don't know what is this and how can this be processed
#        self.print_flag_desc(e)
        self.print_specials(e)
        self.print_entity_foot()


# ==============================================================================
# Entity output in XML format used by NetRadiant

class EntPrinter:
    @staticmethod
    def sanitize(s):
        # FIXME: use XML module
        s = s.replace('<', '&gt;')
        s = s.replace('>', '&lt;')
        s = s.replace('"', '&quot;')
        s = s.replace("'", '&apos;')
        return s

    @staticmethod
    def customtype(_type, _bool):
        # See radiant/eclass_xml.cpp for reference.

        # HACK: NetRadiant does not support real4 or integer4,
        # vec4_float and int4_float will default to string.

        netradiant_special_types = {
            "float (yaw)": "angle",
            "vec3_float (yaw pitch roll)": "angles",
            "vec3_float (color)": "color",
            "string (target)": "target",
            "string (targetname)": "targetname",
            "string (sound)": "sound",
            "string (texture)": "texture",
            "string (model)": "model",
            "string (skin)": "skin",
        }

        netradiant_types = {
            'bool': 'boolean',
            'float': 'real',
            'vec3_float': 'real3',
            'int': 'integer',
            'vec2_int': 'integer2',
            'vec3_int': 'integer3',
        }

        proptype = 'string'

        if _bool:
            proptype = 'boolean'
        else:
            if _type in netradiant_special_types.keys():
                proptype = netradiant_special_types[_type]
            else:
                ct = canonize_type(_type)
                if ct in netradiant_types.keys():
                    proptype = netradiant_types[ ct ]

        return proptype

    def print_header(self, fp):
        print('<?xml version="1.0"?>')
        print('<!-- {}'.format(header_prefix))
        print()

        for line in fp.readlines():
            print("{}".format(line).rstrip())

        print('-->')
        print()
        print('<classes>')
        print()

    def print_footer(self):
        print('</classes>')

    def print_entity_head(self, e):
        name = escape_token(e['name'])
        color = 'color="{} {} {}"'.format(*(fmt_float(f) for f in color_to_float_triple(e['color'])))

        if 'size_min' in e and 'size_max' in e:
            # FIXME: point seems to be set in YAML file
            kind = 'point'
            sizes = ' box="{} {} {} {} {} {}"'.format(*(fmt_float(f) for f in e['size_min'] + e['size_max']))
        else:
            kind = 'group'
            sizes = ''
            if not dont_place_dummy_flag:
                flags.insert(0, escape_token('?'))

        specials = ''
        if 'specials' in e and e['specials']:
            for k, v in e['specials'].items():
                specials += ' {}="{}"'.format(k, v)

        print('<{} name="{}" {}{}{}>'.format(kind, name, color, sizes, specials))

    def print_entity_foot(self, e):
        if 'size_min' in e and 'size_max' in e:
            kind = 'point'
        else:
            kind = 'group'
        print('</{}>'.format(kind))

    def print_flag_desc(self, e):
        flags = []
        for bit, (k, v) in enumerate(e.get('flags', [])):
            if k != '-':
                v = self.sanitize(v)
                # FIXME: key can be different than name
                # according to radiant/eclass_xml.cpp:
                # key="[flag name]"
                # name="[name shown in gui]"
                # bit="[bit-index in spawnflags]"
                flags.append('<flag key="{}" name="{}" bit="{}">{}</flag>'.format(k, k, bit, v))

        if flags:
            print(heading.format('FLAGS'))
            for v in flags:
                print(v)

    def print_prop_desc(self, e, dt, pr_types, pr_defaults, pr_ranges, pr_eg):
        if 'props' not in e or not e['props']:
            return

        print(heading.format('PROPERTIES'))
        proptypes, propdefaults, propranges, propreplace, propeg, boolvalues = \
            (e.get(k, {}) for k in ('proptypes', 'propdefaults', 'propranges', 'propreplace', 'propeg', 'boolvalues'))

        for k, v in sort_properties(e['props']):
            _type = proptypes[k] if k in proptypes else (dt[k] if k in dt else None)
            _bool = k in boolvalues
            info = []
            if pr_types and _type is not None:
                info.append(_type)
            if pr_eg and k in propeg:
                info.append('eg: {}'.format(outvalue(propeg[k], _type)))
            if pr_ranges and k in propranges:
                v1, v2 = propranges[k]
                info.append('{}..{}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_ranges and _bool:
                v1, v2 = boolvalues[k]
                info.append('{} or {}'.format(outvalue(v1, _type), outvalue(v2, _type)))
            if pr_defaults and k in propdefaults:
                v1 = propdefaults[k]
                if _bool:
                    v1 = boolvalues[k][1 if v1 else 0]
                info.append('def: {}'.format(outvalue(v1, _type)))
            if info:
                info = ' ({})'.format(', '.join(info))
            else:
                info = ''
            if k in propreplace:
                for _from, _to in propreplace[k].items():
                    v = v.replace(_from, _to)

            proptype = self.customtype(_type, _bool)

            value = self.sanitize(v.rstrip())
            info = self.sanitize(info)

            default = ''
            if k in propdefaults:
                defaultvalue = outvalue(propdefaults[k], _type)
                defaultvalue = self.sanitize(defaultvalue)
                default=' value="{}"'.format(defaultvalue)

            print('<{} key="{}" name="{}"{}>{}{}</{}>'.format(proptype, k, k, default, value, info, proptype))

    def print_common_desc(self, e):
        if e.get('desc', '').strip():
            print(heading.format('DESCRIPTION'))
            v = e['desc']
            if 'descreplace' in e:
                for _from, _to in e['descreplace'].items():
                    v = v.replace(_from, _to)

            v = self.sanitize(v)

            print(v)

    def print_entity(self, e, dt, pr_types=False, pr_defaults=False, pr_ranges=False, pr_eg=False):
        self.print_entity_head(e)
        if e.get('deprecated'):
            print(deprecated_prefix)
            if e.get('aliasof'):
                print('{} {}'.format(recommended_prefix, e.get('aliasof')))
        self.print_common_desc(e)
        self.print_flag_desc(e)
        self.print_prop_desc(e, dt, pr_types, pr_defaults, pr_ranges, pr_eg)
        #self.print_specials(e)
        self.print_entity_foot(e)
        print()


# ==============================================================================
# Entity output in fgd format used by J.A.C.K

class FgdPrinter:
    @staticmethod
    def remove_quotes(text):
        return text.replace('"', '\'')

    @staticmethod
    def prepare_description(text):
        return FgdPrinter.remove_quotes(text).rstrip().replace('\n', '\\n')

    @staticmethod
    def customtype(_type):
        proptype = 'string'

        fgd_special_types = {
            'string (model)': 'studio',
            'string (target)': 'target_destination',
            'string (targetname)': 'target_source',
            'string (sound)': 'sound',
        }

        fgd_types = {
            'int': 'integer',
        }

        if _type in fgd_special_types.keys():
            proptype = fgd_special_types[ _type ]
        else:
            ct = canonize_type(_type)
            if ct in fgd_types.keys():
              proptype = fgd_types[ ct ]

        return proptype

    def print_header(self, fp):
        print('// {}'.format(header_prefix))
        print('//')

        for line in fp.readlines():
            print("// {}".format(line).rstrip())

        print('')

    def print_footer(self):
        pass

    def print_entity_head(self, e):
        name = e['name']
        nonsolid = 'size_min' in e and 'size_max' in e
        studio_model = ''
        additional = ''
        flags = ''
        offset = ''
        if nonsolid:
            if 'props' in e and ('angle' in e['props'] or 'angles' in e['props']):
                flags = ' flags(Angle)'
            entclass = 'PointClass'
            if name.startswith('team_human_') or name.startswith('team_alien_'):
                offset = ' offset(0 0 {})'.format(round(abs(e['size_min'][2])) + 1) # so entities will be placed a bit above floor to prevent their vanishing
            sizes = ' size({} {} {}, {} {} {})'.format(*(fmt_float(f) for f in e['size_min'] + e['size_max']))
            color = ' color({} {} {})'.format(*(fmt_float(f) for f in color_to_float_triple256(e['color'])))
            if 'specials' in e and 'model' in e['specials']:
                studio_model = ' studio("{}")'.format(e['specials']['model'])
            elif 'props' in e and ('model2' in e['props'] or 'model' in e['props']):
                studio_model = ' studio()'
            if name == 'light' or name == 'lightJunior':
                studio_model = ' iconsprite("sprites/light.spr")'
                flags = ' flags(Light)'
        else:
            entclass = 'SolidClass'
            sizes = ''
            color = ''
        if 'desc' in e:
            token_limit = 2047
            desc = e['desc'].strip().replace('\n', '\\n\\n')
            desc = FgdPrinter.remove_quotes(desc)
            desc = ' + '.join(['"' + desc[i:i+token_limit] + '"' for i in range(0, len(desc), token_limit)])
        else:
            desc = '""'
        print('@{}{}{}{}{}{} = {} : {}'.format(entclass, flags, sizes, color, studio_model, offset, name, desc))

    def print_spawnflags(self, flags):
        for i, (k, v) in enumerate(flags):
            if k != '-':
                print('\t\t{} : "{}" : : "{}"'.format(2**i, k.lower().capitalize(), FgdPrinter.prepare_description(v)))

    def print_properties(self, e, dt, pr_types, pr_defaults, pr_ranges, pr_eg):
        proptypes, propdefaults, propranges, propreplace, propeg, boolvalues = \
            (e.get(k, {}) for k in ('proptypes', 'propdefaults', 'propranges', 'propreplace', 'propeg', 'boolvalues'))

        for k, v in sort_properties(e['props']):
            _type = proptypes[k] if k in proptypes else (dt[k] if k in dt else None)
            _bool = k in boolvalues

            default_value = ''
            if pr_defaults and k in propdefaults:
                v1 = propdefaults[k]
                if _bool:
                    v1 = boolvalues[k][1 if v1 else 0]
                default_value = outvalue(v1, _type)
                if type(default_value) == str and not default_value.isnumeric():
                    default_value = '"' + default_value + '"'

            if k in propreplace:
                for _from, _to in propreplace[k].items():
                    v = v.replace(_from, _to)

            proptype = self.customtype(_type)
            v = self.prepare_description(v)
            display_name = k.capitalize()

            print('\t{}({}) : {} : {} : "{}"'.format(k, proptype, display_name, default_value, v))

        flags = e.get('flags', [])
        if (len(flags)):
            print('\tspawnflags(flags) = ')
            print('\t[')
            self.print_spawnflags(flags)
            print('\t]')

    def print_entity(self, e, dt, pr_types=False, pr_defaults=False, pr_ranges=False, pr_eg=False):
        self.print_entity_head(e)
        print('[')
        self.print_properties(e, dt, pr_types, pr_defaults, pr_ranges, pr_eg)
        print(']')
        print()


# ==============================================================================
# validators

def _validate_int(v):
    return type(v) == int

def _validate_string(v):
    return type(v) == str

def _validate_float(v):
    return type(v) in (int, float)

def _validate_vec2_float(v):
    return isinstance(v, (list, tuple)) and len(v) == 2 and all(_validate_float(x) for x in v)

def _validate_vec3_float(v):
    return isinstance(v, (list, tuple)) and len(v) == 3 and all(_validate_float(x) for x in v)

def _validate_vec4_float(v):
    return isinstance(v, (list, tuple)) and len(v) == 4 and all(_validate_float(x) for x in v)

def _validate_vec9_float(v):
    return isinstance(v, (list, tuple)) and len(v) == 9 and all(_validate_float(x) for x in v)

def _validate_float_array(v):
    return isinstance(v, (list, tuple)) and all(_validate_float(x) for x in v)

def _validate_time_2float(v):
    if isinstance(v, (list, tuple)):
        return _validate_vec2_float(v)
    return _validate_float(v)

def _validate_vec2_int(v):
    return isinstance(v, (list, tuple)) and len(v) == 2 and all(_validate_int(x) for x in v)

def _validate_vec3_int(v):
    return isinstance(v, (list, tuple)) and len(v) == 3 and all(_validate_int(x) for x in v)

def canonize_type(t):
    t = str(t)
    if ' ' in t:
        t, _ = t.split(' ', 1)
    return t

def val_fields_exist(e):
    if d:
        re
    return all(
        'name' in e,
        'props' in e
    )

required_fields = {'name', 'color'}
required_fields2 = required_fields | {'size_min', 'size_max'}
additional_fields = {'propreplace', 'proptypes', 'propdefaults', 'propranges', 'boolvalues', 'propeg'}
all_fields = required_fields2 | additional_fields | {'deprecated', 'descreplace', 'specials', 'aliasof', 'flags', 'props', 'desc'}

def validate_entity(e, dt):
    r = []

    # required fields presence
    d = required_fields - e.keys()
    if d:
        r.append('No required fields: {}'.format(d))
        return r
    if 'size_min' in e or 'size_max' in e:
        d = required_fields2 - e.keys()
        if d:
            r.append('No required fields: {}'.format(d))
            return r

    # unknown fields
    d = e.keys() - all_fields
    if d:
        r.append('Unknown fields: {}'.format(d))
        return r

    # prop* keys consistency
    props = set(e.get('props', {}).keys())
    for k in additional_fields:
        val = set(e.get(k, {}).keys())
        x = val - props
        if x:
            r.append('Non-existent properties ({}) in {}: {}'.format(len(x), k, x))

    boolvalues, propdefaults, propeg, propranges, propreplace, proptypes =\
        (set(e.get(k, {}).keys()) for k in sorted(additional_fields))

    possible_types = proptypes | set(dt.keys())

    # if we have default, we must have known type
    x = propdefaults - possible_types
    if x:
        r.append('Properties ({}) in defaults are not exist in types: {}'.format(len(x), x))

    # if we have value range, we must have known type
    x = propranges - possible_types
    if x:
        r.append('Properties ({}) in ranges are not exist in types: {}'.format(len(x), x))

    # value cannot have range and be bool at the same time
    x = propranges & boolvalues
    if x:
        r.append('Properties ({}) have ranges and boolvalues at the same time: {}'.format(len(x), x))

    etypes = e.get('proptypes', {})

    # validate types
    unknown_types = set()
    for field, ftype in etypes.items():
        ftype = canonize_type(ftype)
        # unknown
        func_name = '_validate_{}'.format(ftype)
        if func_name not in globals():
            unknown_types.add(ftype)
            r.append('Property type {}:{} is unknown'.format(field, ftype))
        # duplicates
        if field in dt and ftype == canonize_type(dt[field]):
            r.append('Property type {}:{} duplicates entry from deftypes'.format(field, ftype))

    # validate types of default values
    for field in propdefaults & possible_types:
        ftype = canonize_type(etypes[field] if field in etypes else dt[field])
        if ftype in unknown_types:
            continue
        func_name = '_validate_{}'.format(ftype)
        v = e['propdefaults'][field]
        if isinstance(v, bool) and field in boolvalues:
            if not isinstance(e['boolvalues'][field], list) or len(e['boolvalues'][field]) != 2:
                r.append('Invalid bool list of prop {}'.format(field))
            else:
                for bv in e['boolvalues'][field]:
                    if not globals()[func_name](bv):
                        r.append('Invalid bool value {} of prop {}, must be of type {}'.format(bv, field, ftype))
        elif not globals()[func_name](v):
            r.append('Invalid default value of {}: {}, must be of type {}'.format(field, v, ftype))

    # validate types of range values
    for field in propranges & possible_types:
        ftype = canonize_type(etypes[field] if field in etypes else dt[field])
        if ftype in unknown_types:
            continue
        func_name = '_validate_{}'.format(ftype)
        v = e['propranges'][field]
        if not isinstance(v, list) or len(v) != 2:
            r.append('Invalid range of prop {}'.format(field))
        else:
            v1, v2 = v
            if not globals()[func_name](v1):
                r.append('Invalid min value of {}: {}, must be of type {}'.format(field, v1, ftype))
            if not globals()[func_name](v2):
                r.append('Invalid max value of {}: {}, must be of type {}'.format(field, v2, ftype))
            # todo: check max>min

    # validate types of examples
    for field in propeg & possible_types:
        ftype = canonize_type(etypes[field] if field in etypes else dt[field])
        if ftype in unknown_types:
            continue
        func_name = '_validate_{}'.format(ftype)
        v = e['propeg'][field]
        if not globals()[func_name](v):
            r.append('Invalid example value of {}: {}, must be of type {}'.format(field, v, ftype))

    if unknown_types:
        r.append('Types ({}) are unknown: {}'.format(len(unknown_types), unknown_types))

    return r


# ==============================================================================
# coverage


def entity_type_coverage(e, dt):
    props = set(e['props'].keys())
    proptypes = set(e.get('proptypes', {}).keys())
    propdefaults = set(e.get('propdefaults', {}).keys())

    t = proptypes | (props & set(dt.keys()))

    if len(t) < len(props):
        print('{}%: {}'.format(len(t) * 100 // len(props), e['name']))


# ==============================================================================
# main

def get_additional_file_name(mainname, f):
    d = os.path.dirname(mainname)
    fname = os.path.basename(mainname).split('.')
    if fname[-1] in ('yaml', 'yml'):
        fname.insert(-1, f)
    else:
        fname.append(f)
    return os.path.join(d, '.'.join(fname))

def load_yaml_file(name):
    if not os.path.isfile(name):
        return {}
    with open(name, 'r') as f:
        text = f.read()
        data = yaml.load(text, Loader=yaml.FullLoader)
    return data

def fix_flag_lists(data):
    for i, e in enumerate(data):
        if 'flags' not in e:
            continue
        e['flags'] = list_of_dicts_to_list_of_tuples(e['flags'])

def apply_baseclass_to_entity(base, ent):
    tmp = deepcopy(base)

    processed = {'desc', 'extend'}

    for key in ('flags', 'color', 'aliasof', 'size_min', 'size_max', 'name', 'd3Class', 'deprecated'):
        processed.add(key)
        if key in ent:
            tmp[key] = ent[key]

    for key in ('props', 'proptypes', 'propreplace', 'boolvalues', 'propeg', 'propdefaults', 'descreplace', 'propranges', 'specials'):
        processed.add(key)
        if key in ent:
            if key not in tmp:
                tmp[key] = {}
            tmp[key].update(ent[key])

    desc = (ent.get('desc', '') + '\n' + base.get('desc', '')).strip('\n ')
    if desc:
        tmp['desc'] = desc

    if set(ent.keys()) - processed:
        raise Exception('Properties not processed: {}'.format(set(ent.keys()) - processed))

    return tmp

def apply_aliasof(data):
    for i, e in enumerate(data):
        if 'aliasof' not in e:
            continue
        try:
            tmp = next(t_ for t_ in data if t_['name'] == e['aliasof'])
        except StopIteration:
            raise Exception('Invalid aliasof: {}'.format(e['aliasof']))
        tmp = deepcopy(tmp)
        tmp.update(e)
        data[i] = tmp

def apply_extends_to_entity(e, common):
    counted = []
    notcounted = e.get('extend', [])
    while notcounted:
        for name in notcounted[:]:
            if name not in counted:
                # check
                if name not in common:
                    raise Exception('Unknown extend {} in {}'.format(name, e))
                # add new deps
                notcounted.extend(x for x in common[name].get('extend', []) if x not in counted and x not in notcounted)
            counted.append(name)
            notcounted.remove(name)
    # now we have full dep list
    for name in counted:
        e = apply_baseclass_to_entity(common[name], e)
    return e

def apply_extend(data, common):
    for i, e in enumerate(data):
        data[i] = apply_extends_to_entity(e, common)

def cleanup_null_props(data):
    for e in data:
        props = e.get('props', {}).copy()
        for k, v in e.get('props', {}).items():
            if v is None:
                del props[k]
        e['props'] = props

def load_yamls(filename):
    data = load_yaml_file(filename)
    deftypes = load_yaml_file(get_additional_file_name(filename, 'deftypes'))
    common = load_yaml_file(get_additional_file_name(filename, 'common'))

    fix_flag_lists(data)
    fix_flag_lists(common)

    apply_aliasof(data)
    apply_extend(data, common)

    cleanup_null_props(data)

    return data, deftypes


format_printer = {
    "q3def": Q3DefPrinter,
    "d3def": D3DefPrinter,
    "ent": EntPrinter,
    "fgd": FgdPrinter,
}

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    description="Generates editor entity definition files.")

group = parser.add_argument_group(title="actions")
group = group.add_mutually_exclusive_group(required=True)
group.add_argument("-s", "--validate", action="store_true", help="Validate YAML syntax")
group.add_argument("-g", "--generate", action="store_true", help="Generate entities file")
group.add_argument("-c", "--coverage", action="store_true", help="Analyse completeness of data")

parser.add_argument("-T", "--types", dest="gtypes", action="store_true", help="Output types of values")
parser.add_argument("-D", "--defaults", dest="gdefaults", action="store_true", help="Output default values")
parser.add_argument("-R", "--ranges", dest="granges", action="store_true", help="Output possible value ranges")
parser.add_argument("-E", "--examples", dest="gexamples", action="store_true", help="Output example values")

parser.add_argument("-d", "--dummyflag", action="store_true",
    help="Use in unpatched Radiant: https://github.com/TTimo/GtkRadiant/issues/262")

parser.add_argument("-p", "--header", help="Prepend a header to the generated file")

parser.add_argument("filename", metavar="entities.yaml", help="Path to input file")
parser.add_argument("format", choices=format_printer.keys(), help="Output format")

args = parser.parse_args()
elist, deftypes = load_yamls(args.filename)

dont_place_dummy_flag = not args.dummyflag

if args.validate:
    warns = []
    for e in elist:
        w = validate_entity(e, deftypes)
        w = ['{}: {}'.format(e['name'], line) for line in w]
        warns.extend(w)

    if not warns:
        print('No warnings! File is OK.')
    else:
        for w in warns:
            print(w)
        print('==================')
        print('Warning count: {}'.format(len(warns)))
        exit(1)

elif args.coverage:
    for e in elist:
        entity_type_coverage(e, deftypes)

elif args.generate:
    opts = {
        'pr_types': args.gtypes,
        'pr_defaults': args.gdefaults,
        'pr_ranges': args.granges,
        'pr_eg': args.gexamples,
    }

    if args.format in format_printer.keys():
        out_printer = format_printer[args.format]()
    else:
        raise Exception('Unknown format: {}'.format(args.format))

    if args.header:
        with open(args.header, "r") as fp:
            out_printer.print_header(fp)
    else:
        out_print.print_header("Game entity definitions file for level editor")

    for e in elist:
        out_printer.print_entity(e, deftypes, **opts)

    out_printer.print_footer()
